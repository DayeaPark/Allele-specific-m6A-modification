---
title: "ASM_analysis"
author: "DP"
date: "2024-03-13"
---

## Load packages 
```{r}
library("reshape2")
library("data.table")
library("tidyverse")
library("data.table")

## Load packages for plot 
library("ggplot2")
library("ggpubr")
```

## Load your m6Anet output files. 
## Four files are needed for this analysis m6Anet output using all, alternative, reference, and undefined read groups)
```{r}
m6Anet_all_rep1 = read.csv("./m6Anet_output/mESC_rep1_all.csv.gz", header = TRUE, sep = ",")
m6Anet_alt_rep1 = read.csv("./m6Anet_output/mESC_rep1_alt.csv.gz", header = TRUE, sep = ",")
m6Anet_ref_rep1 = read.csv("./m6Anet_output/mESC_rep1_ref.csv.gz", header = TRUE, sep = ",")
m6Anet_und_rep1 = read.csv("./m6Anet_output/mESC_rep1_und.csv.gz", header = TRUE, sep = ",")

m6Anet_all_rep2 = read.csv("./m6Anet_output/mESC_rep2_all.csv.gz", header = TRUE, sep = ",")
m6Anet_alt_rep2 = read.csv("./m6Anet_output/mESC_rep2_alt.csv.gz", header = TRUE, sep = ",")
m6Anet_ref_rep2 = read.csv("./m6Anet_output/mESC_rep2_ref.csv.gz", header = TRUE, sep = ",")
m6Anet_und_rep2 = read.csv("./m6Anet_output/mESC_rep2_und.csv.gz", header = TRUE, sep = ",")

## Load vcf file
rename_default <- function(names){
  return(unlist(strsplit(names, split = "[|]"))[6])
}

mouse_vcf_snp_pre = read.csv("./m6Anet_output/mouse_noheader.vcf.gz", header = FALSE, sep = "\t")

mouse_vcf_snp_pre$gene = sapply(mouse_vcf_snp_pre$V1, rename_default)
mouse_vcf_snp = mouse_vcf_snp_pre[-1, c(6,2,3,4)]
colnames(mouse_vcf_snp) = c("gene", "transcript_pos","ALT", "REF")
```
##########################################
## 1. Prepare datasets for ASM analysis. 
## Reframe data format and merge all four datasets
## You can set the probability threshold, but the default is 0.85.

```{r}
reframe_m6Anet <- function (df) {
  df$gene = sapply(df$transcript_id, rename_default)
  df_select = df[,c(7,2:6)]
  return(df_select)
}

make_merge_file_with_prob_filter <- function(all, alt, ref, und, probability = 0.85) {
  df_all = reframe_m6Anet(all)
  df_alt = reframe_m6Anet(alt)
  df_ref = reframe_m6Anet(ref)
  df_und = reframe_m6Anet(und)
  
  column_select = c("gene", "transcript_position", "n_reads", "probability_modified", "mod_ratio"  )
  df_all_new = df_all[,column_select]
  df_alt_new = df_alt[,column_select]
  df_ref_new = df_ref[,column_select]
  df_und_new = df_und[,column_select]
  
  merge_df1 = merge(df_all_new, df_alt_new, by = c("gene", "transcript_position"), all.x = TRUE)
  merge_df2 = merge(merge_df1, df_ref_new, by = c("gene", "transcript_position"), all.x = TRUE)
  new_merge_df = merge(merge_df2, df_und_new, by = c("gene", "transcript_position"), all.x = TRUE)
  
  colnames( new_merge_df) = c("gene", "transcript_position",
                              "all_n_reads", "all_prob", "all_mod_ratio",
                              "alt_n_reads", "alt_prob", "alt_mod_ratio",
                              "ref_n_reads", "ref_prob", "ref_mod_ratio",
                              "und_n_reads", "und_prob", "und_mod_ratio")
  
  new_merge_df[is.na(new_merge_df)] <- 0
  
  new_merge_df$n_read_dif = new_merge_df$all_n_reads - (new_merge_df$alt_n_reads + new_merge_df$ref_n_reads + new_merge_df$und_n_reads)
  new_merge_df$Gene = paste0(new_merge_df$gene, "_", new_merge_df$transcript_position)
  
  new_merge_df_prob85 <- new_merge_df[new_merge_df$all_prob > probability, ]
  
  return(new_merge_df_prob85)
}

prob85_merge_rep1 = make_merge_file_with_prob_filter(m6Anet_all_rep1, m6Anet_alt_rep1, m6Anet_ref_rep1, m6Anet_und_rep1)


prob85_merge_rep2 = make_merge_file_with_prob_filter(m6Anet_all_rep2, m6Anet_alt_rep2, m6Anet_ref_rep2, m6Anet_und_rep2)

```
## 2. Data process for ASM analysis - excluding DRACH to non-DRACH conversion 
```{r}
### Step 1: SNP finder 
### SNP on motif sites were selected from masked all m6Anet output. 
### all, alt, ref, und data frames were merged to all dataset. 
SNP_mark <- function(df_nofilter, pos_num, mark) {
  df = df_nofilter[df_nofilter$alt_mod_ratio + df_nofilter$ref_mod_ratio > 0, ]
  
  df$transcript_pos = df$transcript_position + pos_num
  site_mark <- merge(mouse_vcf_snp, df, by = c("gene", "transcript_pos"))
  
  if (nrow(site_mark) > 0 ) { site_mark$SNP_pos = mark}
  
  return(site_mark)
}


SNP_finder_drach <- function(df) { 
  SNP_find_df = rbind(SNP_mark(df, (-1), "D_site"),
                      SNP_mark(df, 0, "R_site"),
                      SNP_mark(df, 1, "A_site"),
                      SNP_mark(df, 2, "C_site"),
                      SNP_mark(df, 3, "H_site") )
  
  return(SNP_find_df) 
}

SNP_included_m6A_rep1  = SNP_finder_drach(prob85_merge_rep1)
SNP_included_m6A_rep2  = SNP_finder_drach(prob85_merge_rep2)

## Step 2: DRACH nucleotide check
#In this section, I will identify SNPs that do not shape in the DRACH motif (noDRACH > DRACH or DRACH > noDRACH). 

DRACH_both_allele <- function(df) {
  D = c("A", "G", "T")
  R = c("A", "G")
  A = c("A")
  H = c("A", "C", "T")
  
  Dsite = df[df$SNP_pos == "D_site",]
  Rsite = df[df$SNP_pos == "R_site",]
  Asite = df[df$SNP_pos == "A_site",]
  Hsite = df[df$SNP_pos == "H_site",]
  
  Dsite_DRACH = Dsite[Dsite$ALT %in% D & Dsite$REF %in% D, ]
  Rsite_DRACH = Rsite[Rsite$ALT %in% R & Rsite$REF %in% R, ]
  Hsite_DRACH = Hsite[Hsite$ALT %in% H & Hsite$REF %in% H, ]
  DRACH = rbind(Dsite_DRACH, Rsite_DRACH, Hsite_DRACH)
  
  DRACH[is.na(DRACH)] <- 0
  DRACH_select = DRACH[DRACH$alt_mod_ratio + DRACH$ref_mod_ratio > 0,]
  return(DRACH_select)
}

DRACH_prob85_rep1 = DRACH_both_allele(SNP_included_m6A_rep1)
DRACH_prob85_rep2 = DRACH_both_allele(SNP_included_m6A_rep2)
```

## 3. Data process for ASM analysis 
```{r}

##include non-converted DRACH motif sites 
preset_df_rep1 = rbind (prob85_merge_rep1[!(prob85_merge_rep1$Gene %in% SNP_included_m6A_rep1$Gene), ], 
                   prob85_merge_rep1[prob85_merge_rep1$Gene %in% DRACH_prob85_rep1$Gene, ])
preset_df_rep2 = rbind (prob85_merge_rep2[!(prob85_merge_rep2$Gene %in% SNP_included_m6A_rep2$Gene), ], 
                   prob85_merge_rep2[prob85_merge_rep2$Gene %in% DRACH_prob85_rep2$Gene, ])

ASM_filter1_vcf <-function (df_nofilter) { 
  df_nofilter[is.na(df_nofilter)] <- 0
  df = df_nofilter[df_nofilter$gene %in% mouse_vcf_snp$gene_name, ]
  
  filter_zero = df_nofilter[(df_nofilter$alt_n_reads + df_nofilter$ref_n_reads) > 0, ]
  
  return(filter_zero)
}

ASM_filter1_rep1 = ASM_filter1_vcf(preset_df_rep1)
ASM_filter1_rep2 = ASM_filter1_vcf(preset_df_rep2)


## Select data which has read count more than 19 from both allele. 
### all_n_read = (alt_n_read + ref_n_read + und_n_read) or both alt and ref 'n_read' valued higher than 19. 
ASM_filter2_rep1 = ASM_filter1_rep1[ASM_filter1_rep1$ref_n_reads > 19 & ASM_filter1_rep1$alt_n_reads > 19, ]
ASM_filter2_rep2 = ASM_filter1_rep2[ASM_filter1_rep2$ref_n_reads > 19 & ASM_filter1_rep2$alt_n_reads > 19, ]

```

## 4. Data process for ASM anaylsis - Recalculation and filter read number over 10. 
### (alt n_read + ref n_read) > 0
###  Recalculate mod_ratio 
alt mod ratio =  ((all n_read ∗ all mod ratio) -(ref n_read ∗ ref mod ratio"))/ alt n_read
ref mod ratio =  ((all n_read ∗ all mod ratio) -(alt n_read ∗ alt mod ratio"))/ ref n_read
###The function include the filter 4 (n_read difference > 10)

```{r}
## Recount mod ratio 
## 1) alt and ref n_read were filled with n_read differences. 
## 2) if undefined read has modification ratio, I included und_mod_ratio for calculation. However, if und_n_read is zero, I ignore the effects of undefined reads. 
## As a result, recounted mod ratio is not over 1. 

recalculate_mod_ratio <- function (filter1_df, n_read_threshold = 10) {
  filter2_out_df = filter1_df[!(filter1_df$ref_n_reads > 19 & filter1_df$alt_n_reads > 19), ]
  df =  filter2_out_df[filter2_out_df$n_read_dif > 0, ]
 
    for (i in 1:nrow(df)) {
      if (df$alt_n_reads[i] == 0 ) {
        df$alt_n_reads[i] <- df$n_read_dif[i]
        
        if (df$und_n_reads[i] > 0 ) {
          df$alt_mod_ratio[i] = ((df$all_n_reads[i] * df$all_mod_ratio[i]) - (df$ref_n_reads[i] * df$ref_mod_ratio[i]) - (df$und_n_reads[i] * df$und_mod_ratio[i]))/df$alt_n_reads[i]  
        } else if (df$und_n_reads[i] == 0 )
          df$alt_mod_ratio[i] = ((df$all_n_reads[i] * df$all_mod_ratio[i]) - (df$ref_n_reads[i] * df$ref_mod_ratio[i]) )/df$alt_n_reads[i]
          
      } else if (df$ref_n_reads[i] == 0 ) {
        df$ref_n_reads[i] <- df$n_read_dif[i]
       
        if (df$und_n_reads[i] > 0 ) {
         df$ref_mod_ratio[i] = ((df$all_n_reads[i] * df$all_mod_ratio[i]) - (df$alt_n_reads[i] * df$alt_mod_ratio[i]) - (df$und_n_reads[i] * df$und_mod_ratio[i] ))/df$ref_n_reads[i]
       } else if (df$und_n_reads[i] == 0 ) {
         df$ref_mod_ratio[i] = ((df$all_n_reads[i] * df$all_mod_ratio[i]) - (df$alt_n_reads[i] * df$alt_mod_ratio[i]) )/df$ref_n_reads[i]
       }}
    }
  final_df = df[df$n_read_dif > n_read_threshold, ]
  return(final_df)
}

ASM_recalculation_rep1 = recalculate_mod_ratio(ASM_filter1_rep1)
ASM_recalculation_rep2 = recalculate_mod_ratio(ASM_filter1_rep2)

```


## 5. Combind datasets from previous two parts for ASM analysis. 
```{r}
## I combined part1 and part2 data tables. 
combined_processed_rep1 = rbind(ASM_filter2_rep1, ASM_recalculation_rep1)
combined_processed_rep2 = rbind(ASM_filter2_rep2, ASM_recalculation_rep2)

final_df = merge(combined_processed_rep1[,c(1:14)], combined_processed_rep2[,c(1:14)], by = c("gene", "transcript_position") )

colnames(final_df) = c("gene", "transcript_position", 
                           "rep1_all_n_reads", "rep1_all_prob", "rep1_all_mod_ratio",
                           "rep1_alt_n_reads", "rep1_alt_prob", "rep1_alt_mod_ratio",
                           "rep1_ref_n_reads", "rep1_ref_prob", "rep1_ref_mod_ratio",
                           "rep1_und_n_reads", "rep1_und_prob", "rep1_und_mod_ratio",
                           "rep2_all_n_reads", "rep2_all_prob", "rep2_all_mod_ratio",
                           "rep2_alt_n_reads", "rep2_alt_prob", "rep2_alt_mod_ratio",
                           "rep2_ref_n_reads", "rep2_ref_prob", "rep2_ref_mod_ratio",
                           "rep2_und_n_reads", "rep2_und_prob", "rep2_und_mod_ratio")

final_df$Gene = paste0(final_df$gene, "_", final_df$transcript_position)

```


############### ASM analysis ###############  

### reframe for bootsrap 
```{r}
## Re-frame function will change the data format for the boostrapping step including calculation of methylated sites. 
reframe_for_bootstrap <- function (m6A_df , prob_threshold) { 
    colnames(m6A_df) = c( "gene", "transcript_position", 
                              "all_n_reads", "all_prob_mod", "all_mod_ratio", 
                              "alt_n_reads", "alt_prob_mod", "alt_mod_ratio",
                              "ref_n_reads", "ref_prob_mod", "ref_mod_ratio",
                              "und_n_reads", "und_prob_mod", "und_mod_ratio")
    
    m6A_allele  = m6A_df[m6A_df$all_prob_mod > prob_threshold,]
    m6A_allele$Gene = paste0(m6A_allele$gene, "_", m6A_allele$transcript_position)
    
    m6A_allele$alt_methylated = m6A_allele$alt_n_reads * m6A_allele$alt_mod_ratio
    m6A_allele$ref_methylated = m6A_allele$ref_n_reads * m6A_allele$ref_mod_ratio
 
    m6A_allele_count = m6A_allele[,c("Gene", "alt_n_reads", "alt_methylated", "alt_mod_ratio","ref_n_reads", "ref_methylated", "ref_mod_ratio")]
    return(m6A_allele_count)
}

## This step, you will resample the methylated read counts to get the p-value. 

set.seed(3)

p_value_of_each_site <- function ( df_all, sample_n, effect_size_threshold) {
  
    df_modcount  = reframe_for_bootstrap(df_all[,c(1:14)], 0.85)
    
    for(i in 1:nrow(df_modcount)) {
      if (df_modcount$alt_n_reads[i] > 0 & df_modcount$ref_n_reads[i] > 0 ) {
        methylated_alt = c(rep(1,df_modcount$alt_methylated[i]), rep(0,df_modcount$alt_n_reads[i] - df_modcount$alt_methylated[i]))
        methylated_ref = c(rep(1,df_modcount$ref_methylated[i]), rep(0,df_modcount$ref_n_reads[i] - df_modcount$ref_methylated[i]))
        
        alt_bootstrap = colSums(replicate(sample(methylated_alt, length(methylated_alt), replace = TRUE), n = sample_n ))/length(methylated_alt)
        ref_bootstrap = colSums(replicate(sample(methylated_ref, length(methylated_ref), replace = TRUE), n = sample_n ))/length(methylated_ref)
        
        pvalue_ref_high = 1- sum((ref_bootstrap - alt_bootstrap) > effect_size_threshold) / length(ref_bootstrap-alt_bootstrap)
        pvalue_alt_high = 1- sum((alt_bootstrap - ref_bootstrap) > effect_size_threshold) / length(ref_bootstrap-alt_bootstrap)
        
        df_modcount$pvalue_ref[i] <- pvalue_ref_high
        df_modcount$pvalue_alt[i] <- pvalue_alt_high
        
      } else if (df_modcount$alt_n_reads[i] == 0 | df_modcount$ref_n_reads[i] == 0 ) {
        print("zero read count found!")
        df_modcount$pvalue_ref[i] = "none"
        df_modcount$pvalue_alt[i] = "none" }
    }
    
return(df_modcount[,c("Gene","alt_mod_ratio","ref_mod_ratio", "pvalue_ref", "pvalue_alt")])
}

mouse_rep1_pvalue = p_value_of_each_site(combined_processed_rep1, 1000, 0.1)
mouse_rep2_pvalue = p_value_of_each_site(combined_processed_rep2, 1000, 0.1)

```

### biased p_value and plot
## Define p-value based on the methylation biasness. 
```{r}
## pvalue from methylation biasness.
 p_value_bias <- function (df_p_value) { 
    for (i in 1:nrow (df_p_value)) { 
      if(df_p_value$alt_mod_ratio[i] > df_p_value$ref_mod_ratio[i]) { 
        df_p_value$bias_pvalue[i] = df_p_value$pvalue_alt[i]
      } else if(df_p_value$alt_mod_ratio[i] < df_p_value$ref_mod_ratio[i]) { 
        df_p_value$bias_pvalue[i] = df_p_value$pvalue_ref[i]}
      }
   return(df_p_value[,c(1:3,6)]) 
    }
mouse_rep1_biase_p <- p_value_bias(mouse_rep1_pvalue)
mouse_rep2_biase_p <- p_value_bias(mouse_rep2_pvalue)

### ASM determination
mouse_merge_bias_p = merge(mouse_rep1_biase_p %>% select("Gene", contains("pvalue") ),
                           mouse_rep2_biase_p %>% select("Gene", contains("pvalue") ), by = "Gene", all = TRUE)
colnames(mouse_merge_bias_p) = c("Gene", "rep1_pvalue", "rep2_pvalue")
mouse_ASM_pval <- na.omit(mouse_merge_bias_p)

pvalue_cutoff = -log(0.05)
mouse_ASM <- mouse_ASM_pval[-log(mouse_ASM_pval$rep1_pvalue) > pvalue_cutoff & -log(mouse_ASM_pval$rep2_pvalue) > pvalue_cutoff,]

## PLOT: merge two datasets (Fig 3B)
pvalue_cutoff = -log(0.05,10)

ggplot(mouse_ASM_pval, aes(x= -log(rep1_pvalue,10), y = -log(rep2_pvalue,10)) )+ 
  geom_point(size = 1, shape = 19, alpha = 1/2) +
  geom_hline(yintercept= pvalue_cutoff, linetype="dashed", color = "red", size=0.2)+
  geom_vline(xintercept= pvalue_cutoff, linetype="dashed", color = "red", size=0.2) + 
  theme_classic() 

```


## ASM plot
```{r}

mod_dif_plot <- function ( df ) { 
  df$ASM_type = "none"
  df[df$Gene %in% mouse_ASM$Gene, ]$ASM_type <- "ASM"

  df$rep1_mod_dif = df$rep1_ref_mod_ratio - df$rep1_alt_mod_ratio
  df$rep2_mod_dif = df$rep2_ref_mod_ratio - df$rep2_alt_mod_ratio
  
  dif_threhold = 0.33
  
  ggplot(df, aes(x= rep1_mod_dif, y = rep2_mod_dif, color = ASM_type)) + 
    geom_point(size = 1, shape = 19, alpha = 1/2) +
    theme_classic() +
    geom_hline(yintercept=c(-dif_threhold, dif_threhold), linetype="dashed", color = "red", size=0.2) +
    geom_vline(xintercept=c(-dif_threhold, dif_threhold), linetype="dashed", color = "red", size=0.2) +
    scale_color_manual(values = c("none" = "lightgrey", "ASM" = "blue") )

}

mod_dif_plot(final_df)


```
